package hr.fer.zemris.java.raytracer;

import java.lang.reflect.Constructor;

import hr.fer.zemris.java.raytracer.model.GraphicalObject;
import hr.fer.zemris.java.raytracer.model.IRayTracerProducer;
import hr.fer.zemris.java.raytracer.model.LightSource;
import hr.fer.zemris.java.raytracer.model.Point3D;
import hr.fer.zemris.java.raytracer.model.Scene;

import javax.swing.SwingUtilities;

/**
 * Viewer utility for RayTracer.
 * 
 * @author marcupic
 *
 */
public class RayTracerViewer {

	/**
	 * This is a helper method which allows creation
	 * of Sphere objects using Java-reflection, so that
	 * class can later be implement by students.
	 * @param center center
	 * @param radius radius
	 * @param kdr kdr
	 * @param kdg kdg
	 * @param kdb kdb
	 * @param krr krr
	 * @param krg krg
	 * @param krb krb
	 * @param krn krn
	 * @return new sphere or {@link RuntimeException} for errors
	 */
	private static GraphicalObject createSphere(Point3D center, double radius, double kdr, double kdg,
			double kdb, double krr, double krg, double krb, double krn) {
		try {
			Class<?> clazz = Class.forName("hr.fer.zemris.java.raytracer.model.Sphere");
			Constructor<?> constr = clazz.getConstructor(Point3D.class,double.class,double.class,double.class,double.class,double.class,double.class,double.class,double.class);
			return (GraphicalObject)constr.newInstance(center, radius, kdr, kdg, kdb, krr, krg, krb, krn);
		} catch(Exception ex) {
			throw new RuntimeException("Could not create a Sphere.", ex);
		}
	}
	
	/**
	 * A sample method that creates a scene used in homework description.
	 * 
	 * @return sample scene
	 */
	public static Scene createPredefinedScene() {
		Scene scene = new Scene();
		scene
			.add(createSphere(new Point3D(-2,-2,2), 5, 1, 1, 1, 0.5, 0.5, 0.5, 10))
			.add(createSphere(new Point3D(-2,2,-3), 5, 1, 1, 1, 0.5, 0.5, 0.5, 10))
			.add(new LightSource(new Point3D(10,5,5), 100, 0, 0))
			.add(new LightSource(new Point3D(10,-5,5), 0, 80, 80))
			.add(new LightSource(new Point3D(2,5,-1), 80, 80, 0))
			;
		
		for(int i = 0; i < 10; i++) {
			for(int j = 0; j < 10; j++) {
				scene.add(
					createSphere(
						new Point3D(-5,i/9.0*25-12.5,j/9.0*25-12.5),   // center
						0.5,  // radius
						1,    // kdr
						1,    // kdg 
						1,    // kdb
						0.5,  // krr
						0.5,  // kgr 
						0.5,  // kbr
						4     // krn
					)
				);
			}
		}
		
		return scene;
	}
	
	/**
	 * Show a scene based on given producer and default parameters:
	 * eye = new Point3D(10,0,0), view = new Point3D(0,0,0), viewUp = new Point3D(0,0,10),
	 * horizontal = 20 and vertical = 20.
	 * 
	 * @param iRayTraceProducer producer
	 */
	public static void show(final IRayTracerProducer iRayTraceProducer) {
		if(SwingUtilities.isEventDispatchThread()) {
			showInEDT(iRayTraceProducer);
		}
		SwingUtilities.invokeLater(new Runnable() {
			@Override
			public void run() {
				showInEDT(iRayTraceProducer);
			}
		});
	}

	/**
	 * Private helper method...
	 * 
	 * @param iRayTraceProducer producer
	 */
	private static void showInEDT(IRayTracerProducer iRayTraceProducer) {
		RayTracerViewerFrame fvf = new RayTracerViewerFrame(iRayTraceProducer);
		fvf.setVisible(true);
	}

	/**
	 * Show a scene based on given producer and parameters.
	 * @param iRayTraceProducer produces
	 * @param eye position of eye
	 * @param view position that is observed
	 * @param viewUp approximation of viewUp vector
	 * @param horizontal horizontal width of observed space
	 * @param vertical vertical height of observed space
	 */
	public static void show(final IRayTracerProducer iRayTraceProducer, final Point3D eye, final Point3D view, final Point3D viewUp, final double horizontal, final double vertical) {
		if(SwingUtilities.isEventDispatchThread()) {
			showInEDT(iRayTraceProducer, eye, view, viewUp, horizontal, vertical);
		}
		SwingUtilities.invokeLater(new Runnable() {
			@Override
			public void run() {
				showInEDT(iRayTraceProducer, eye, view, viewUp, horizontal, vertical);
			}
		});
	}

	/**
	 * Private helper method...
	 * 
	 * @param iRayTraceProducer produces
	 * @param eye position of eye
	 * @param view position that is observed
	 * @param viewUp approximation of viewUp vector
	 * @param horizontal horizontal width of observed space
	 * @param vertical vertical height of observed space
	 */
	private static void showInEDT(IRayTracerProducer iRayTraceProducer, final Point3D eye, final Point3D view, final Point3D viewUp, final double horizontal, final double vertical) {
		RayTracerViewerFrame fvf = new RayTracerViewerFrame(iRayTraceProducer, eye, view, viewUp, horizontal, vertical);
		fvf.setVisible(true);
	}
}
