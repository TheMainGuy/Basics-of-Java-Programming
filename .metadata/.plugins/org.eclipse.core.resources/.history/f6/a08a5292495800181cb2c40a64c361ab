package hr.fer.zemris.java.gui.calc;

import java.util.ArrayList;
import java.util.List;
import java.util.function.DoubleBinaryOperator;

public class CalcModelImpl implements CalcModel {
  private String currentNumber = null;
  private double activeOperand = Double.NaN;
  private DoubleBinaryOperator binaryOperator = null;
  private List<CalcValueListener> valueListeners = new ArrayList<>();
  @Override
  public void addCalcValueListener(CalcValueListener l) {
    valueListeners.add(l);
  }

  @Override
  public void removeCalcValueListener(CalcValueListener l) {
    for(int i = 0, n = valueListeners.size(); i < n;i++) {
      if(valueListeners.get(i) == l) {
        valueListeners.remove(i);
        return;
      }
    }
  }

  @Override
  public String toString() {
    return currentNumber == null ? "0" : currentNumber;
  }

  @Override
  public double getValue() {
    return currentNumber == null ? 0.0 : Double.parseDouble(currentNumber);
  }

  @Override
  public void setValue(double value) {
    currentNumber = (value == Double.NaN || value == Double.POSITIVE_INFINITY || value == Double.NEGATIVE_INFINITY)
        ? currentNumber
        : Double.toString(value);

  }

  @Override
  public void clear() {
    currentNumber = null;
  }

  @Override
  public void clearAll() {
    currentNumber = null;
    activeOperand = Double.NaN;
    binaryOperator = null;
  }

  @Override
  public void swapSign() {
    currentNumber = currentNumber == null ? currentNumber : Double.toString(Double.parseDouble(currentNumber) * -1);
    if(currentNumber == null) {
      return;
    }
    if(Double.parseDouble(currentNumber) == Math.floor(Double.parseDouble(currentNumber))) {
      currentNumber = currentNumber.substring(0, currentNumber.indexOf('.'));
    }
  }

  @Override
  public void insertDecimalPoint() {
    if(currentNumber!= null && currentNumber.length() >= 308) {
      return;
    }
    if(currentNumber == null || currentNumber.equals("")) {
      currentNumber = "0.";
      return;
    }
    currentNumber = currentNumber.indexOf('.') == -1 ? currentNumber + '.' : currentNumber;  
  }

  @Override
  public void insertDigit(int digit) {
    if(currentNumber != null && currentNumber.length() >= 308) {
      return;
    }
    if(currentNumber == null) {
      currentNumber = "";
    }
    if(digit == 0 && currentNumber.equals("0")) {
      return;
    }
    if(currentNumber.equals("0") && digit != 0) {
      currentNumber = Integer.toString(digit);
      return;
    }
    currentNumber += digit;

  }

  @Override
  public boolean isActiveOperandSet() {
    return Double.isNaN(activeOperand) ? false : true;
  }

  @Override
  public double getActiveOperand() {
    if(isActiveOperandSet()) {
      return activeOperand;
    }
    throw new IllegalStateException("Active operand is not set.");
  }

  @Override
  public void setActiveOperand(double activeOperand) {
    this.activeOperand = activeOperand;
  }

  @Override
  public void clearActiveOperand() {
    activeOperand = Double.NaN;
  }

  @Override
  public DoubleBinaryOperator getPendingBinaryOperation() {
    return binaryOperator;
  }

  @Override
  public void setPendingBinaryOperation(DoubleBinaryOperator op) {
    binaryOperator = op;
  }
  
  private void notifyValueListeners() {
    for(CalcValueListener valueListener : valueListeners) {
      valueListener.valueChanged(this);
    }
  }

}
