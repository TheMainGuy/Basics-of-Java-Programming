package hr.fer.zemris.java.raytracer;

import java.util.List;

import hr.fer.zemris.java.raytracer.model.GraphicalObject;
import hr.fer.zemris.java.raytracer.model.IRayTracerProducer;
import hr.fer.zemris.java.raytracer.model.IRayTracerResultObserver;
import hr.fer.zemris.java.raytracer.model.LightSource;
import hr.fer.zemris.java.raytracer.model.Point3D;
import hr.fer.zemris.java.raytracer.model.Ray;
import hr.fer.zemris.java.raytracer.model.RayIntersection;
import hr.fer.zemris.java.raytracer.model.Scene;
import hr.fer.zemris.java.raytracer.viewer.RayTracerViewer;

public class RayCaster {
  public static void main(String[] args) {
    RayTracerViewer.show(getIRayTracerProducer(), new Point3D(10, 0, 0), new Point3D(0, 0, 0), new Point3D(0, 0, 10),
        20, 20);
  }

  private static IRayTracerProducer getIRayTracerProducer() {
    return new IRayTracerProducer() {
      @Override
      public void produce(Point3D eye, Point3D view, Point3D viewUp, double horizontal, double vertical, int width,
          int height, long requestNo, IRayTracerResultObserver observer) {
        System.out.println("Započinjem izračune...");
        short[] red = new short[width * height];
        short[] green = new short[width * height];
        short[] blue = new short[width * height];
        Point3D og = view.sub(eye).normalize();
        Point3D vuv = viewUp.normalize();
        Point3D yAxis = vuv.sub(og.scalarMultiply(og.scalarProduct(vuv))).normalize();
        Point3D xAxis = og.vectorProduct(yAxis).normalize();
        Point3D zAxis = yAxis.vectorProduct(xAxis);
        Point3D screenCorner = view.sub(xAxis.scalarMultiply(horizontal / 2)).add(yAxis.scalarMultiply(vertical / 2));
        Scene scene = RayTracerViewer.createPredefinedScene();
        short[] rgb = new short[3];
        int offset = 0;
        for (int y = 0; y < height; y++) {
          for (int x = 0; x < width; x++) {
            Point3D screenPoint = screenCorner.add(xAxis.scalarMultiply(horizontal * x / (width - 1.0)))
                .sub(yAxis.scalarMultiply(vertical * y / (height - 1.0)));
            Ray ray = Ray.fromPoints(eye, screenPoint);
            tracer(scene, ray, rgb);
            red[offset] = rgb[0] > 255 ? 255 : rgb[0];
            green[offset] = rgb[1] > 255 ? 255 : rgb[1];
            blue[offset] = rgb[2] > 255 ? 255 : rgb[2];
            offset++;
          }
        }
        System.out.println("Izračuni gotovi...");
        observer.acceptResult(red, green, blue, requestNo);
        System.out.println("Dojava gotova...");
      }

      private void tracer(Scene scene, Ray ray, short[] rgb) {
        double[] rgb2 = new double[3];
        RayIntersection firstIntersection = firstIntersection(scene, ray);
        if(firstIntersection == null) {
          rgb[0] = 0;
          rgb[1] = 0;
          rgb[2] = 0;
        } else {
          rgb2 = determineColorFor(firstIntersection, scene, ray);
          rgb[0] = (short) rgb2[0];
          rgb[1] = (short) rgb2[1];
          rgb[2] = (short) rgb2[2];
        }
      }

      private double[] determineColorFor(RayIntersection firstIntersection, Scene scene, Ray ray) {
        double[] rgb = new double[3];
        rgb[0] = 15;
        rgb[1] = 15;
        rgb[2] = 15;

        for (LightSource light : scene.getLights()) {
          Ray lightRay = Ray.fromPoints(light.getPoint(), firstIntersection.getPoint());
          RayIntersection lightIntersection = firstIntersection(scene, lightRay);

          if(lightIntersection != null && firstIntersection.getPoint().sub(lightIntersection.getPoint()).norm() <= 0.01) {
            addDiffusseComponent(light, rgb, lightIntersection);
            addReflectiveComponent(light, lightRay, rgb, lightIntersection);
          }
        }
        return rgb;
      }
      private void addDiffusseComponent(LightSource light, double[] rgbCalculated, RayIntersection intersection) {
        Point3D n = intersection.getNormal();
        Point3D l = light.getPoint().sub(intersection.getPoint()).normalize();
        
        double ln = l.scalarProduct(n);
        
        rgbCalculated[0] += light.getR()*intersection.getKdr()*Math.max(ln, 0);
        rgbCalculated[1] += light.getG()*intersection.getKdg()*Math.max(ln, 0);
        rgbCalculated[2] += light.getB()*intersection.getKdb()*Math.max(ln, 0);
      }
      
      private void addReflectiveComponent(LightSource light, Ray ray, double[] rgbCalculated, RayIntersection intersection) {
        Point3D n = intersection.getNormal();
        Point3D l = light.getPoint().sub(intersection.getPoint());
        Point3D lProjectionOnN = n.scalarMultiply(l.scalarProduct(n));
        Point3D r = lProjectionOnN.add(lProjectionOnN.negate().add(l).scalarMultiply(-1));
        Point3D v = ray.start.sub(intersection.getPoint());
        double cos = r.normalize().scalarProduct(v.normalize());
          
        if(Double.compare(cos, 0) >= 0) {
            cos = Math.pow(cos, intersection.getKrn());
            
          rgbCalculated[0] += light.getR()*intersection.getKrr()*cos;
          rgbCalculated[1] += light.getG()*intersection.getKrg()*cos;
          rgbCalculated[2] += light.getB()*intersection.getKrb()*cos;
          }
      }

      /**
       * Helper method which finds the first intersection between given ray and object
       * in given scene.
       * 
       * @param scene scene
       * @param ray ray
       * @return first intersection
       */
      private RayIntersection firstIntersection(Scene scene, Ray ray) {
        List<GraphicalObject> graphicalObjects = scene.getObjects();
        double minDistance = -1;
        RayIntersection firstIntersection = null;
        for (GraphicalObject graphicalObject : graphicalObjects) {
          RayIntersection intersection = graphicalObject.findClosestRayIntersection(ray);
          if(intersection != null) {
            double distance = intersection.getDistance();
            if(distance < minDistance || minDistance == -1) {
              minDistance = distance;
              firstIntersection = intersection;
            }
          }
        }
        return firstIntersection;
      }
    };
  }
}
