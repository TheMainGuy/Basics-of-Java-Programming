package hr.fer.zemris.java.raytracer;

import java.util.List;

import hr.fer.zemris.java.raytracer.model.GraphicalObject;
import hr.fer.zemris.java.raytracer.model.IRayTracerProducer;
import hr.fer.zemris.java.raytracer.model.IRayTracerResultObserver;
import hr.fer.zemris.java.raytracer.model.LightSource;
import hr.fer.zemris.java.raytracer.model.Point3D;
import hr.fer.zemris.java.raytracer.model.Ray;
import hr.fer.zemris.java.raytracer.model.RayIntersection;
import hr.fer.zemris.java.raytracer.model.Scene;
import hr.fer.zemris.java.raytracer.viewer.RayTracerViewer;

public class RayCaster {
  public static int dots = 0;

  public static void main(String[] args) {
    RayTracerViewer.show(getIRayTracerProducer(), new Point3D(10, 0, 0), new Point3D(0, 0, 0), new Point3D(0, 0, 10),
        20, 20);
  }

  private static IRayTracerProducer getIRayTracerProducer() {
    return new IRayTracerProducer() {
      @Override
      public void produce(Point3D eye, Point3D view, Point3D viewUp, double horizontal, double vertical, int width,
          int height, long requestNo, IRayTracerResultObserver observer) {
        System.out.println("Započinjem izračune...");
        short[] red = new short[width * height];
        short[] green = new short[width * height];
        short[] blue = new short[width * height];
        Point3D og = view.sub(eye).normalize();
        Point3D vuv = viewUp.normalize();
        Point3D yAxis = vuv.sub(og.scalarMultiply(og.scalarProduct(vuv))).normalize();
        Point3D xAxis = og.vectorProduct(yAxis).normalize();
        Point3D zAxis = yAxis.vectorProduct(xAxis);
        Point3D screenCorner = view.sub(xAxis.scalarMultiply(horizontal / 2)).add(yAxis.scalarMultiply(vertical / 2));
        Scene scene = RayTracerViewer.createPredefinedScene();
        short[] rgb = new short[3];
        int offset = 0;
        for (int y = 0; y < height; y++) {
          for (int x = 0; x < width; x++) {
            Point3D screenPoint = screenCorner.add(xAxis.scalarMultiply(horizontal * x / (width - 1.0)))
                .sub(yAxis.scalarMultiply(vertical * y / (height - 1.0)));
            Ray ray = Ray.fromPoints(eye, screenPoint);
            tracer(scene, ray, rgb);
            red[offset] = rgb[0] > 255 ? 255 : rgb[0];
            green[offset] = rgb[1] > 255 ? 255 : rgb[1];
            blue[offset] = rgb[2] > 255 ? 255 : rgb[2];
            offset++;
          }
        }
        System.out.println(dots);
        System.out.println("Izračuni gotovi...");
        observer.acceptResult(red, green, blue, requestNo);
        System.out.println("Dojava gotova...");
      }

      private void tracer(Scene scene, Ray ray, short[] rgb) {
        double[] rgb2 = new double[3];
        RayIntersection firstIntersection = firstIntersection(scene, ray);
        if(firstIntersection == null) {
          rgb[0] = 0;
          rgb[1] = 0;
          rgb[2] = 0;
        } else {
          rgb2 = determineColorFor(firstIntersection, scene, ray);
          rgb[0] = (short) rgb2[0];
          rgb[1] = (short) rgb2[1];
          rgb[2] = (short) rgb2[2];
        }

      }

      /**
       * Helper method which finds the first intersection between given ray and object
       * in given scene.
       * 
       * @param scene scene
       * @param ray ray
       * @return first intersection
       */
      private RayIntersection firstIntersection(Scene scene, Ray ray) {
        List<GraphicalObject> graphicalObjects = scene.getObjects();
        double minDistance = -1;
        RayIntersection firstIntersection = null;
        for (GraphicalObject graphicalObject : graphicalObjects) {
          RayIntersection intersection = graphicalObject.findClosestRayIntersection(ray);
          if(intersection != null) {
            double distance = intersection.getDistance();
            if(distance < minDistance || minDistance == -1) {
              minDistance = distance;
              firstIntersection = intersection;
            }
          }
        }
        return firstIntersection;
      }

      /**
       * Method determines color for one picture element.
       * 
       * @param firstIntersection intersection which is looked upon
       * @param scene scene
       * @param observer 
       * @return
       */
      private double[] determineColorFor(RayIntersection firstIntersection, Scene scene, Ray observer) {
        double[] rgb = new double[3];
        rgb[0] = 15;
        rgb[1] = 15;
        rgb[2] = 15;

        for (LightSource light : scene.getLights()) {
          Ray ray = Ray.fromPoints(light.getPoint(), firstIntersection.getPoint());
          RayIntersection intersection2 = firstIntersection(scene, ray);
          if(intersection2 != null && firstIntersection.getPoint().sub(intersection2.getPoint()).norm() <= 0.01) {
            double cos = intersection2.getNormal().scalarProduct(ray.direction.negate())
                / (intersection2.getNormal().norm() * ray.direction.norm());
            cos = (cos < 0) ? 0 : cos;
            rgb[0] += light.getR() * intersection2.getKdr() * cos;
            rgb[1] += light.getG() * intersection2.getKdg() * cos;
            rgb[2] += light.getB() * intersection2.getKdb() * cos;

            Point3D r = ray.direction.sub(intersection2.getNormal()
                .scalarMultiply(ray.direction.scalarMultiply(2).scalarProduct(intersection2.getNormal())));
            Point3D v = observer.direction.negate();
            double cos2 = r.scalarProduct(v);
            cos2 = (cos2 < 0) ? 0 : cos2;
            rgb[0] += light.getR() * intersection2.getKrr() * Math.pow(cos2, intersection2.getKrn());
            rgb[1] += light.getG() * intersection2.getKrg() * Math.pow(cos2, intersection2.getKrn());
            rgb[2] += light.getB() * intersection2.getKrb() * Math.pow(cos2, intersection2.getKrn());
          }
        }
        return rgb;
      }

    };
  }

}
